// Sistema din√¢mico de carregamento de dados do CSV

// Paleta de cores natural e moderna
const naturalColors = {
    primary: ['#2d5016', '#1a4731', '#0d9488', '#059669', '#166534'],
    secondary: ['#4ade80', '#22c55e', '#16a34a', '#15803d', '#14532d'],
    teal: ['#0d9488', '#0f766e', '#134e4a', '#115e59', '#042f2e'],
    gradients: {
        green: 'linear-gradient(135deg, #059669 0%, #0d9488 100%)',
        forest: 'linear-gradient(135deg, #1a4731 0%, #166534 100%)',
        teal: 'linear-gradient(135deg, #0d9488 0%, #0f3460 100%)'
    }
};

// Configura√ß√£o padr√£o do Chart.js
Chart.defaults.font.family = 'Inter, sans-serif';
Chart.defaults.font.size = 12;
Chart.defaults.color = '#6b7280';

// Fun√ß√£o para carregar e processar CSV dinamicamente
async function loadCSVData() {
    try {
        const response = await fetch('database_dashboard.csv');
        const csvText = await response.text();
        
        // Processar CSV
        const lines = csvText.trim().split('\n');
        const headers = lines[0].split(';').map(header => header.trim());
        
        const data = [];
        
        for (let i = 1; i < lines.length; i++) {
            const values = lines[i].split(';').map(value => value.trim());
            const entry = {};
            
            headers.forEach((header, index) => {
                entry[header] = values[index] || '';
            });
            
            data.push(entry);
        }
        
        console.log(`‚úÖ Carregados ${data.length} registros do CSV`);
        console.log('üìä Campos detectados:', headers);
        
        return data;
    } catch (error) {
        console.error('‚ùå Erro ao carregar CSV:', error);
        return [];
    }
}

// Fun√ß√£o para obter dados da semana (come√ßando na ter√ßa-feira)
function getWeeklyData(data) {
    if (!data || data.length === 0) {
        console.warn('‚ö†Ô∏è Nenhum dado fornecido para filtro semanal');
        return [];
    }
    
    // Data de refer√™ncia: ter√ßa-feira, 9 de setembro de 2025
    const referenceDate = new Date(2025, 8, 9); // M√™s 8 = setembro (0-indexed)
    
    // Encontrar a ter√ßa-feira mais recente
    const today = new Date();
    const currentDay = today.getDay(); // 0 = domingo, 1 = segunda, 2 = ter√ßa, etc.
    
    let daysToSubtract;
    if (currentDay >= 2) { // Se hoje √© ter√ßa ou depois
        daysToSubtract = currentDay - 2; // Dias desde a ter√ßa
    } else { // Se hoje √© domingo ou segunda
        daysToSubtract = currentDay + 5; // Dias desde a ter√ßa passada
    }
    
    const currentTuesday = new Date(today);
    currentTuesday.setDate(today.getDate() - daysToSubtract);
    currentTuesday.setHours(0, 0, 0, 0);
    
    console.log(`üìÖ Ter√ßa-feira atual: ${currentTuesday.toLocaleDateString('pt-BR')}`);
    
    return data.filter(item => {
        // Detectar campo de data dinamicamente
        const dateField = item.data || item.Data || item.DATE || item.date || Object.values(item)[0];
        
        if (!dateField) return false;
        
        try {
            const [datePart] = dateField.split(' ');
            const [day, month, year] = datePart.split('/');
            const itemDate = new Date(year, month - 1, day);
            
            return itemDate >= currentTuesday;
        } catch (error) {
            console.warn(`‚ö†Ô∏è Erro ao processar data: ${dateField}`);
            return false;
        }
    });
}

// Fun√ß√£o para animar n√∫meros
function animateNumber(elementId, finalValue) {
    const element = document.getElementById(elementId);
    if (!element) return;
    
    const duration = 1500;
    const steps = 60;
    const increment = finalValue / steps;
    let current = 0;
    
    const timer = setInterval(() => {
        current += increment;
        if (current >= finalValue) {
            element.textContent = finalValue;
            clearInterval(timer);
        } else {
            element.textContent = Math.floor(current);
        }
    }, duration / steps);
}

// Criar gr√°fico donut din√¢mico
function createDynamicDonutChart(canvasId, data, title) {
    const ctx = document.getElementById(canvasId).getContext('2d');
    
    if (!data || Object.keys(data).length === 0) {
        // Se n√£o h√° dados, mostrar mensagem
        ctx.fillStyle = '#6b7280';
        ctx.font = '14px Inter';
        ctx.textAlign = 'center';
        ctx.fillText('Sem dados dispon√≠veis', ctx.canvas.width / 2, ctx.canvas.height / 2);
        return null;
    }
    
    // Limitar labels longos
    const labels = Object.keys(data).map(label => {
        if (label.length > 25) {
            return label.substring(0, 22) + '...';
        }
        return label;
    });
    
    const values = Object.values(data);
    const total = values.reduce((a, b) => a + b, 0);
    
    // Plugin √∫nico para texto central din√¢mico
    const centerTextPlugin = {
        id: 'centerText',
        beforeDraw: function(chart) {
            const ctx = chart.ctx;
            const centerX = (chart.chartArea.left + chart.chartArea.right) / 2;
            const centerY = (chart.chartArea.top + chart.chartArea.bottom) / 2;
            
            ctx.save();
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // Pegar os valores din√¢micos ou usar padr√£o
            const displayValue = chart.hoverValue || total;
            const displayLabel = chart.hoverLabel || 'Total';
            
            ctx.fillStyle = '#2d5016';
            ctx.font = 'bold 24px Inter';
            ctx.fillText(displayValue, centerX, centerY - 8);
            
            ctx.fillStyle = '#6b7280';
            ctx.font = '14px Inter';
            ctx.fillText(displayLabel, centerX, centerY + 15);
            ctx.restore();
        }
    };
    
    const chart = new Chart(ctx, {
        type: 'doughnut',
        data: {
            labels: labels,
            datasets: [{
                data: values,
                backgroundColor: naturalColors.primary,
                borderColor: '#ffffff',
                borderWidth: 3,
                hoverBorderWidth: 4,
                hoverOffset: 6,
                hoverBackgroundColor: naturalColors.secondary
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    display: false
                },
                tooltip: {
                    enabled: true,
                    backgroundColor: 'rgba(0, 0, 0, 0.9)',
                    titleColor: '#ffffff',
                    bodyColor: '#ffffff',
                    borderColor: '#2d5016',
                    borderWidth: 2,
                    cornerRadius: 8,
                    displayColors: false,
                    padding: 12,
                    titleFont: {
                        size: 14,
                        weight: 'bold'
                    },
                    bodyFont: {
                        size: 13
                    },
                    animation: {
                        duration: 200
                    },
                    callbacks: {
                        title: function(context) {
                            const originalLabels = Object.keys(data);
                            return originalLabels[context[0].dataIndex];
                        },
                        label: function(context) {
                            const percentage = ((context.parsed / total) * 100).toFixed(1);
                            return `${context.parsed} contribui√ß√µes (${percentage}%)`;
                        }
                    }
                }
            },
            cutout: '65%',
            animation: {
                animateRotate: true,
                animateScale: true,
                duration: 1200,
                easing: 'easeInOutQuart'
            },
            interaction: {
                intersect: false,
                mode: 'point'
            },
            onHover: (event, activeElements, chart) => {
                if (activeElements.length > 0) {
                    const dataIndex = activeElements[0].index;
                    const value = values[dataIndex];
                    const percentage = ((value / total) * 100).toFixed(1);
                    
                    // Definir valores para hover
                    chart.hoverValue = value;
                    chart.hoverLabel = `${percentage}%`;
                } else {
                    // Limpar valores de hover
                    chart.hoverValue = null;
                    chart.hoverLabel = null;
                }
                chart.update('none');
            }
        },
        plugins: [centerTextPlugin]
    });
    
    return chart;
}

// Criar gr√°fico de linha din√¢mico
function createDynamicLineChart(canvasId, data, title) {
    const ctx = document.getElementById(canvasId).getContext('2d');
    
    if (!data || data.length === 0) {
        // Se n√£o h√° dados, mostrar mensagem
        ctx.fillStyle = '#6b7280';
        ctx.font = '14px Inter';
        ctx.textAlign = 'center';
        ctx.fillText('Sem dados dispon√≠veis', ctx.canvas.width / 2, ctx.canvas.height / 2);
        return null;
    }
    
    // Detectar campo de data dinamicamente
    const dateField = data.length > 0 ? 
        (data[0].data || data[0].Data || data[0].DATE || data[0].date || Object.keys(data[0])[0]) : null;
    
    if (!dateField) {
        ctx.fillStyle = '#6b7280';
        ctx.font = '14px Inter';
        ctx.textAlign = 'center';
        ctx.fillText('Campo de data n√£o encontrado', ctx.canvas.width / 2, ctx.canvas.height / 2);
        return null;
    }
    
    // Processar dados para timeline
    const timelineData = {};
    data.forEach(item => {
        const dateValue = item[dateField] || item[Object.keys(item)[0]];
        if (!dateValue) return;
        
        const [datePart] = dateValue.split(' ');
        timelineData[datePart] = (timelineData[datePart] || 0) + 1;
    });
    
    const sortedDates = Object.keys(timelineData).sort((a, b) => {
        const [dayA, monthA, yearA] = a.split('/');
        const [dayB, monthB, yearB] = b.split('/');
        return new Date(yearA, monthA - 1, dayA) - new Date(yearB, monthB - 1, dayB);
    });
    
    const values = sortedDates.map(date => timelineData[date]);
    const labels = sortedDates.map(date => {
        const [day, month] = date.split('/');
        return `${day}/${month}`;
    });
    
    const chart = new Chart(ctx, {
        type: 'line',
        data: {
            labels: labels,
            datasets: [{
                label: 'Contribui√ß√µes',
                data: values,
                borderColor: '#059669',
                backgroundColor: 'rgba(5, 150, 105, 0.1)',
                borderWidth: 3,
                fill: true,
                tension: 0.4,
                pointBackgroundColor: '#ffffff',
                pointBorderColor: '#059669',
                pointBorderWidth: 2,
                pointRadius: 5,
                pointHoverRadius: 7,
                pointHoverBackgroundColor: '#059669',
                pointHoverBorderColor: '#ffffff',
                pointHoverBorderWidth: 3
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    display: false
                },
                tooltip: {
                    backgroundColor: 'rgba(0, 0, 0, 0.8)',
                    titleColor: '#ffffff',
                    bodyColor: '#ffffff',
                    borderColor: '#2d5016',
                    borderWidth: 1,
                    cornerRadius: 8,
                    displayColors: false,
                    callbacks: {
                        title: function(context) {
                            const originalDate = sortedDates[context[0].dataIndex];
                            return `Data: ${originalDate}`;
                        },
                        label: function(context) {
                            const value = context.parsed.y;
                            return `${value} ${value === 1 ? 'contribui√ß√£o' : 'contribui√ß√µes'}`;
                        }
                    }
                }
            },
            scales: {
                x: {
                    grid: {
                        display: false
                    },
                    ticks: {
                        color: '#6b7280',
                        font: {
                            size: 11
                        }
                    }
                },
                y: {
                    beginAtZero: true,
                    grid: {
                        color: 'rgba(107, 114, 128, 0.1)',
                        drawBorder: false
                    },
                    ticks: {
                        color: '#6b7280',
                        font: {
                            size: 11
                        },
                        stepSize: 1
                    }
                }
            },
            animation: {
                duration: 1000,
                easing: 'easeInOutQuart'
            },
            interaction: {
                intersect: false,
                mode: 'index'
            }
        }
    });
    
    return chart;
}

// Adicionar canvas aos containers de gr√°ficos
function addCanvasToCharts() {
    const chartContainers = [
        'sectionsChart', 'changesChart', 'timelineChart',
        'weeklySectionsChart', 'weeklyChangesChart', 'weeklyTimelineChart'
    ];
    
    chartContainers.forEach(containerId => {
        const container = document.getElementById(containerId);
        if (container && !container.querySelector('canvas')) {
            const canvas = document.createElement('canvas');
            canvas.id = containerId + 'Canvas';
            canvas.style.maxHeight = '300px';
            container.appendChild(canvas);
        }
    });
}

// Inicializar dashboard com dados din√¢micos
document.addEventListener('DOMContentLoaded', async function() {
    console.log('üöÄ Inicializando dashboard din√¢mico...');
    
    // Adicionar canvas aos containers primeiro
    addCanvasToCharts();
    
    console.log('üìä Canvas adicionados, aguardando carregamento...');
    
    try {
        // Carregar dados do CSV
        const csvData = await loadCSVData();
        
        if (!csvData || csvData.length === 0) {
            console.warn('‚ö†Ô∏è Nenhum dado encontrado no CSV');
            return;
        }
        
        console.log(`‚úÖ ${csvData.length} registros carregados do CSV`);
        
        // Debug: mostrar primeiros registros
        console.log('üîç Primeiros 3 registros:', csvData.slice(0, 3));
        console.log('üîç Campos detectados:', Object.keys(csvData[0] || {}));
        
        // Calcular estat√≠sticas din√¢micas
        const stats = calculateStats(csvData);
        console.log('üìä Estat√≠sticas calculadas:', stats);
        
        // PRIMEIRO: Atualizar cards de estat√≠sticas
        console.log('üéØ Atualizando cards...');
        updateStatsCards(csvData);
        
        // SEGUNDO: Aguardar um pouco para os cards serem atualizados
        await new Promise(resolve => setTimeout(resolve, 100));
        
        // TERCEIRO: Processar dados para gr√°ficos din√¢micos
        console.log('üìà Processando dados para gr√°ficos...');
        const authorData = processAuthorData(csvData);
        const sectionData = processSectionData(csvData);
        const weeklyData = getWeeklyData(csvData);
        
        console.log('üë• Dados por autor:', authorData);
        console.log('üìù Dados por se√ß√£o:', sectionData);
        console.log('üìÖ Dados semanais:', weeklyData.length, 'contribui√ß√µes');
        
        // QUARTO: Criar gr√°ficos din√¢micos
        console.log('üé® Criando gr√°ficos...');
        createDynamicDonutChart('sectionsChartCanvas', sectionData, 'Contribui√ß√µes por Se√ß√£o');
        createDynamicDonutChart('changesChartCanvas', processChangeData(csvData), 'Tipos de Mudan√ßa Proposta');
        createDynamicLineChart('timelineChartCanvas', csvData, 'Evolu√ß√£o das Contribui√ß√µes');
        
        // SE√á√ÉO SEMANAL - usando dados filtrados
        const weeklySectionData = processSectionData(weeklyData);
        const weeklyChangeData = processChangeData(weeklyData);
        
        createDynamicDonutChart('weeklySectionsChartCanvas', weeklySectionData, 'Se√ß√µes (Semanal)');
        createDynamicDonutChart('weeklyChangesChartCanvas', weeklyChangeData, 'Tipos de Mudan√ßa (Semanal)');
        createDynamicLineChart('weeklyTimelineChartCanvas', weeklyData, 'Tend√™ncia Semanal');
        
        // QUINTO: Adicionar efeitos de hover nos cards
        addHoverEffects();
        
        // SEXTO: Atualizar timestamp
        updateLastUpdate();
        
        console.log('‚ú® Dashboard din√¢mico inicializado com sucesso!');
        
    } catch (error) {
        console.error('‚ùå Erro ao carregar dados do CSV:', error);
        
        // Fallback: mostrar mensagem de erro
        const containers = document.querySelectorAll('.chart-container canvas');
        containers.forEach(canvas => {
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#6b7280';
            ctx.font = '14px Inter';
            ctx.textAlign = 'center';
            ctx.fillText('Erro ao carregar dados', canvas.width / 2, canvas.height / 2);
            ctx.fillText('Verifique o arquivo CSV', canvas.width / 2, canvas.height / 2 + 20);
        });
    }
});

// Calcular estat√≠sticas gerais dos dados
function calculateStats(data) {
    const stats = {
        total: data.length,
        thisWeek: 0,
        authors: new Set(),
        sections: new Set()
    };
    
    const weeklyData = getWeeklyData(data);
    stats.thisWeek = weeklyData.length;
    
    // Contar autores √∫nicos
    data.forEach(item => {
        const author = item[Object.keys(item).find(key => 
            key.toLowerCase().includes('autor') || key.toLowerCase().includes('author')
        )];
        if (author) stats.authors.add(author);
        
        const section = item[Object.keys(item).find(key => 
            key.toLowerCase().includes('se√ß√£o') || 
            key.toLowerCase().includes('secao') || 
            key.toLowerCase().includes('section')
        )];
        if (section) stats.sections.add(section);
    });
    
    return {
        total: stats.total,
        thisWeek: stats.thisWeek,
        authors: stats.authors.size,
        sections: stats.sections.size
    };
}

// Atualizar cards de estat√≠sticas com dados reais
function updateStatsCards(data) {
    console.log('üîß Iniciando updateStatsCards com', data.length, 'registros');
    
    const stats = calculateStats(data);
    console.log('üìä Stats calculadas em updateStatsCards:', stats);
    
    // Verificar se os elementos existem
    const elements = {
        totalElement: document.getElementById('total-contributions'),
        contributorsElement: document.getElementById('unique-contributors'),
        weeklyTotalElement: document.getElementById('weekly-total'),
        weeklyContributorsElement: document.getElementById('weekly-contributors'),
        mostCommentedElement: document.getElementById('most-commented-section'),
        weeklyMostCommentedElement: document.getElementById('weekly-most-commented-section')
    };
    
    Object.entries(elements).forEach(([name, element]) => {
        console.log(`üîç Elemento ${name}:`, element ? 'ENCONTRADO' : 'N√ÉO ENCONTRADO');
    });
    
    // Atualizar elementos por ID
    if (elements.totalElement) {
        console.log('üìà Atualizando total-contributions para:', stats.total);
        animateNumber('total-contributions', stats.total);
    }
    if (elements.contributorsElement) {
        console.log('üìà Atualizando unique-contributors para:', stats.authors);
        animateNumber('unique-contributors', stats.authors);
    }
    if (elements.weeklyTotalElement) {
        console.log('üìà Atualizando weekly-total para:', stats.thisWeek);
        animateNumber('weekly-total', stats.thisWeek);
    }
    if (elements.weeklyContributorsElement) {
        // Para dados semanais, calcular autores √∫nicos da semana
        const weeklyData = getWeeklyData(data);
        const weeklyAuthors = new Set();
        weeklyData.forEach(item => {
            const author = item[Object.keys(item).find(key => 
                key.toLowerCase().includes('autor') || key.toLowerCase().includes('author')
            )];
            if (author) weeklyAuthors.add(author);
        });
        console.log('üìà Atualizando weekly-contributors para:', weeklyAuthors.size);
        animateNumber('weekly-contributors', weeklyAuthors.size);
    }
    
    // Atualizar se√ß√£o mais comentada (total)
    if (elements.mostCommentedElement) {
        const sectionData = processSectionData(data);
        console.log('üìä Dados de se√ß√µes:', sectionData);
        const mostCommented = Object.keys(sectionData).length > 0 ? 
            Object.keys(sectionData).reduce((a, b) => 
                sectionData[a] > sectionData[b] ? a : b
            ) : 'Nenhuma se√ß√£o';
        
        // Limitar texto longo
        const displayText = mostCommented.length > 30 ? 
            mostCommented.substring(0, 27) + '...' : mostCommented;
        console.log('üìà Atualizando most-commented-section para:', displayText);
        elements.mostCommentedElement.textContent = displayText;
    }
    
    // Atualizar se√ß√£o mais comentada (semanal)
    if (elements.weeklyMostCommentedElement) {
        const weeklyData = getWeeklyData(data);
        const weeklySectionData = processSectionData(weeklyData);
        console.log('üìä Dados de se√ß√µes semanais:', weeklySectionData);
        const weeklyMostCommented = Object.keys(weeklySectionData).length > 0 ? 
            Object.keys(weeklySectionData).reduce((a, b) => 
                weeklySectionData[a] > weeklySectionData[b] ? a : b
            ) : 'Nenhuma se√ß√£o';
        
        // Limitar texto longo
        const displayText = weeklyMostCommented.length > 30 ? 
            weeklyMostCommented.substring(0, 27) + '...' : weeklyMostCommented;
        console.log('üìà Atualizando weekly-most-commented-section para:', displayText);
        elements.weeklyMostCommentedElement.textContent = displayText;
    }
    
    console.log('‚úÖ Cards atualizados com sucesso!');
}

// Processar dados por autor dinamicamente
function processAuthorData(data) {
    const authorStats = {};
    
    data.forEach(item => {
        const author = item[Object.keys(item).find(key => 
            key.toLowerCase().includes('autor') || key.toLowerCase().includes('author')
        )] || 'Autor n√£o identificado';
        
        authorStats[author] = (authorStats[author] || 0) + 1;
    });
    
    return authorStats;
}

// Processar dados por tipo de mudan√ßa dinamicamente
function processChangeData(data) {
    const changeStats = {};
    
    data.forEach(item => {
        const change = item.mudanca_proposta || item['mudan√ßa_proposta'] || item.mudanca || 'Tipo n√£o identificado';
        changeStats[change] = (changeStats[change] || 0) + 1;
    });
    
    return changeStats;
}

// Processar dados por se√ß√£o dinamicamente
function processSectionData(data) {
    const sectionStats = {};
    
    data.forEach(item => {
        const section = item[Object.keys(item).find(key => 
            key.toLowerCase().includes('se√ß√£o') || 
            key.toLowerCase().includes('secao') || 
            key.toLowerCase().includes('section') ||
            key.toLowerCase().includes('categoria') ||
            key.toLowerCase().includes('category')
        )] || 'Se√ß√£o n√£o identificada';
        
        sectionStats[section] = (sectionStats[section] || 0) + 1;
    });
    
    return sectionStats;
}

// Atualizar timestamp da √∫ltima atualiza√ß√£o
function updateLastUpdate() {
    const now = new Date();
    const timestamp = now.toLocaleString('pt-BR');
    
    const updateElement = document.getElementById('update-time');
    if (updateElement) {
        updateElement.textContent = timestamp;
    }
    
    console.log(`üïê √öltima atualiza√ß√£o: ${timestamp}`);
}

// Adicionar efeitos de hover modernos
function addHoverEffects() {
    const cards = document.querySelectorAll('.modern-stat, .modern-chart');
    
    cards.forEach(card => {
        card.addEventListener('mouseenter', function() {
            this.style.transform = 'translateY(-4px) scale(1.02)';
            this.style.transition = 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
        });
        
        card.addEventListener('mouseleave', function() {
            this.style.transform = 'translateY(0) scale(1)';
        });
    });
}

// Fun√ß√£o para atualiza√ß√£o em tempo real (simulada)
function simulateRealTimeUpdates() {
    setInterval(() => {
        const now = new Date();
        document.getElementById('update-time').textContent = now.toLocaleString('pt-BR');
    }, 60000); // Atualiza a cada minuto
}
